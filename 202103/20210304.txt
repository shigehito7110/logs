==と===の違い
==は型の比較は行わない(抽象的比較)こちらの方は暗黙的方変換が行われる例：true =>1など
===は肩の比較まで行う(厳格的比較)
特別な理由がない限りは厳格の方を使用した方が良さそう。
ES6からデフォルト引数が追加されたため、関数の引数内で初期化を行う。
Jsのデータ型はプリミティブ型(オブジェクト以外stringやnuberなど)とオブジェクト(プリミティブ型以外　関数も含む)が存在する
プリミティブ型はimutableでオブジェクトはmutable
Jsの際代入は値の参照先を変更しているだけでletはimmutableの定義
オブジェクトがmutableなのはオブジェクトが持つ参照が中身が変わったも参照もとは変更しないため変更しなくても変更できるという意味合い
オブジェクトのコピーは参照をコピーするため対象が同じになり変更が共有される
プリミティブ型は対象の値のコピーを参照するため、対象が異なっている。
const はオブジェクトの際代入を制限するのみであり、プロパティの変更は可能。

let a = {
  prop: 1
}

function fn(arg) {   arg = {}
} 

fn(a);
ではargにaの参照先をコピーした後にargの参照先を変更しているだけなので、aに影響はない。
関数コンテキストにargumentsは実引数であり仮引数ではない
argumentsはes6になってからレストパラメーター…に代用されているので使用されない
関数は実行可能なオブジェクトであり、プロパティ操作も可能。
thisは呼び出し元のオブジェクトになるtaro.helloでhello: funtion(){cnosole.log(`hello ${this.name}`}の場合はhello person.nameとなる
thisはオブジェクトのメソッドとして呼ばれた場合は呼び出し元のオブジェクトを参照する
関数として呼ばれた場合はグローバルオブジェクトとして呼ばれる(window)
例外はあり
Bindを使用して参照先のオブジェクトを指定することも可能。

関数.bind(arg1, arg2~)となるarg1はオブジェクト、arg2は実引数を渡す。実引数のみ必要な場合はarg1はnullとするのが良い。
関数実行時の仮引数よりbindが優先される。
bindは参照を共有しているわけではなくthisの値を固定した関数を別のメモリ空間に生成している

callとapplyもbindと同様にthisを固定するが、呼ばれた時点で関数を実行する点で動作が異なる。
配列を扱う場合はapply、単一の実引数の場合はcall
配列の場合はapplyを使用するが、callにスプレッド演算子(…)を渡すことで同様の動作をするので、使うことはなさそう。
他の人が書いたコードを読むための知識として覚えておくと良さげ？
アロー関数はthisを取らないため実行コンテキスト内のthisは無視され、レキシカルスコープを辿ってグローバルオブジェクトを参照する(window)

コンストラクタ関数は慣習により頭文字を大文字にする。
コンストラクタ関数により
function  Person(name, age){
  this.name = name;
  this.age = age;
}

const bob = new Person(‘Bob’, 18);のようにインスタンスを生成できる
Rubyのクラスとnewメソッドのような感覚

プロトタイプは特別なプロパティでコンストラクタとセットで使用する。

newの挙動として
コンストラクタのreturnがオブジェクトだった場合はオブジェクトと格納
オブジェクト以外がreturnされた場合はthisを格納する。

new演算子がむずすぎるので要復習
