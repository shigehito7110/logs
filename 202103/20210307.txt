++演算子ではオペランド(演算子によって操作される値)の右に記述するか左に記述するかで結果が変わる。
let a = 0;
let b = a++;
の場合は0を=でbに返してから1をプラスする
let b = ++a;
の場合は1をプラスしてからbに値を返す。
演算子の優先順位に注意

ループ分の場合はブロックスコープが一ループごとに切り替わるのでconstによる再代入が可能。
同じ変数でもメモリ領域は異なっている
Object.defineProperty.method(オブジェクト, ‘プロパティ名’, {設置})
プロトタイプの列挙可能性をfalseにする場合は上記でも可能だが、オブジェクト.hasOwnProperty(キー)でifの条件分岐で書くのが一般的だしわかりやすい
シンボルはenumerableがtrueでも列挙対象ではない

反復操作を行う際に使用するオブジェクトをイテレーター(String, Arrayなどが持っている、これらはfor ofの使用が可能)
Mapとsetはデータを管理するための入れものでコレクションを呼ばれる
Mapはkeyに文字列以外も指定することができる。(関数とかもok)
Mapはfor inで使用できないがfor ofでは使用できる
読み書きが多い場合はmapを使用する

Setは重複値を撮ることができない。for inも使用できない。for ofは使用可能。
Arrayは重複値を撮ることができる。for inとfor ofでの使用も可能。

イテレーターはreturnの中にnextメソッドを必ず保持し、オブジェクトを必ず返す。
オブジェクト内のイテレーターにfunctionを代入し反復可能オブジェクトに変更することが可能。

ジェネレーターを簡単に作成するための関数をジェネレーターを呼ぶ
ジェネレーター関数のreturnでイテレーターを返し、その値を反復操作に使用、イテレーターよりもコード量が格段に少なくなった。
通常はジェネレーターを使用した方がコードの可読性が高いのでジェネレーターを使用した方が良さそう。

関数のデフォルト値の設定色々
function user ({name = ‘shige’} = {}){ }
上記のように{} = {}と設定することでオブジェクトが引数として渡ってこなかった場合のデフォルト値を設定できる。
 MapとSetの復習をした方が良さそうに感じた。
Setは重複値を取ることができないので、同じ関数を実行したくない時などに便利に使用できる
PubSubパターンを調べる
